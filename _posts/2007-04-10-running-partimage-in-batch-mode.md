---
layout: post
title: running partimage in batch mode
date: '2007-04-10T22:01:00.000Z'
author: Tim Abell
tags:
- partimage
- dev
- project
modified_time: '2007-04-11T01:08:46.017Z'
blogger_id: tag:blogger.com,1999:blog-5082828566240519947.post-3391820548015517010
blogger_orig_url: https://timwise.blogspot.com/2007/04/running-partimage-in-batch-mode.html
---

<span style="font-style: italic;">A continuation of the <a href="http://www.partimage.org/">partimage</a> project.</span><br /><br />As it would appear that stdout support doesn't work due the user interface making use of stdout, I have been figuring out how to make the program run in batch mode, with a little help from KDevelop.<br /><br />My continued findings:<br /><br />The help presents a fully batch mode, -B<br /><pre><code>$ ./partimage --help<br />===============================================================================<br />Partition Image (http://www.partimage.org/) version 0.6.5_beta4 [stable]<br />---- distributed under the GPL 2 license (GNU General Public License) ----<br /><br />Supported file systems:....Ext2/3, Reiser3, FAT16/32, HPFS, JFS, XFS,<br />                           UFS(beta), HFS(beta), NTFS(experimental)<br /><br />usage: partimage [options] &lt;action&gt; &lt;device&gt; &lt;image_file&gt;<br />       partimage &lt;imginfo/restmbr&gt; &lt;image_file&gt;<br /><br />ex: partimage -z1 -o -d save /dev/hda12 /mnt/backup/redhat-6.2.partimg.gz<br />ex: partimage restore /dev/hda13 /mnt/backup/suse-6.4.partimg<br />ex: partimage restmbr /mnt/backup/debian-potato-2.2.partimg.bz2<br />ex: partimage -z1 -om save /dev/hda9 /mnt/backup/win95-osr2.partimg.gz<br />ex: partimage imginfo /mnt/backup/debian-potato-2.2.partimg.bz2<br />ex: partimage -a/dev/hda6#/mnt/partimg#vfat -V 700 save /dev/hda12 /mnt/partimg/redhat-6.2.partimg.gz<br /><br />Arguments:<br />* &lt;action&gt;:<br />  - save: save the partition datas in an image file<br />  - restore: restore the partition from an image file<br />  - restmbr: restore a MBR of the image file to an hard disk<br />  - imginfo: show informations about the image file<br />* &lt;device&gt;: partition to save/restore (example: /dev/hda1)<br />* &lt;image_file&gt;: file where data will be read/written. Can be very big.<br />                For restore, &lt;image_file&gt; can have the value 'stdin'. This allows<br />                for providing image files through a pipe.<br /><br />Options:<br />* -z,  --compress      (image file compression level):<br />  -z0, --compress=0    don't compress: very fast but very big image file<br />  -z1, --compress=1    compress using gzip: fast and small image file (default)<br />  -z2, --compress=2    (compress using bzip2: very slow and very small image file):<br />* -c,  --nocheck       don't check the partition before saving<br />* -o,  --overwrite     overwrite the existing image file without confirmation<br />* -d,  --nodesc        don't ask any description for the image file<br />* -V,  --volume        (split image into multiple volumes files)<br />  -VX, --volume=X      create volumes with a size of X MB<br />* -w,  --waitvol       wait for a confirmation after each volume change<br />* -e,  --erase         erase empty blocks on restore with zero bytes<br />* -m,  --allowmnt      don't fail if the partition is mounted. Dangerous !<br />* -M,  --nombr         don't create a backup of the MBR (Mast Boot Record) in the image file<br />* -h,  --help          show help<br />* -v,  --version       show version<br />* -i,  --compilinfo    show compilation options used<br />* -f,  --finish        (action to do if finished successfully):<br />  -f0, --finish=0      wait: don't make anything<br />  -f1, --finish=1      halt (power off) the computer<br />  -f2, --finish=2      reboot (restart the computer):<br />  -f3, --finish=3      quit<br />* -b,  --batch         batch mode: the GUI won't wait for an user action<br /><strong>* -BX, --fully-batch=X batch mode without GUI, X is a challenge response string</strong><br />* -y,  --nosync        don't synchronize the disks at the end of the operation (dangerous)<br />* -sX, --server=X      give partimaged server's ip address<br />* -pX, --port=X        give partimaged server's listening port<br />* -g,  --debug=X       set the debug level to X (default: 1):<br />* -n,  --nossl         disable SSL in network mode<br />* -S,  --simulate      simulation of restoration mode<br />* -aX, --automnt=X     automatic mount with X options. Read the doc for more details<br />* -UX  --username=X    username to authenticate to server<br />* -PX  --password=X    password for authentication of user to server<br />===============================================================================</code></pre><br /><br />It is not immediately obvious what &quot;X is a challenge response string&quot; means.<br />I was able to get the program to run to a limited extend after a bit of searching the internet and trial and error with the option &quot;-B x=y&quot;.<br /><br />Having stepped through the program, it transpires that where I have put &quot;x&quot;, the program expects a pattern to match with the title and content of any messages that would otherwise have been shown to the user, and &quot;y&quot; is the pre-programmed response. This is in the &quot;interface_none&quot; section.<br />&quot;x&quot; has to match the question in the form &quot;message title/message content&quot; and is compared using fnmatch which allows * as a wildcard (anyone got a good reference for fnmatch?).<br />If the program hits a question for the user, and cannot find a matching answer in the command arguments, &quot;CInterfaceNone::invalid_programmed_response()&quot; fires &quot;exit(8)&quot; and the program dies.<br /><br />So far I have been running the program as a normal user, which will inevitably fail where it attempts to work with block devices / root owned files &amp; folders. This produces a warning in the user interface, followed by program termination.<br /><br />To bypass this first &quot;not root&quot; warning, I successfully used this pre-programmed answer:<br />./partimage -B Warning*=Continue<br />Alternatively the following is more specific and also works:<br />./partimage -B Warning*root*=continue<br /><br />I haven't figured out how to pass more than one predefined answer in batch mode.<br /><br />The run arguments can be set in KDevelop here:<br />project &gt; options &gt; debugger &gt; program arguments<br /><br /><em>Side note:</em><br />The program has a base class of user interface defined, and then either instantiates interface_none or interface_newt depending on command line arguments.<br /><br />If not using full batch mode it helps to set &quot;enable separate terminal for application IO&quot; in KDevelop (project &gt; options &gt; debugger) so that you can see the full user interface. However if the program exits then the console closes and any output is lost.<br /><br />As part of stepping through the code, I came across a macro, which makes the program harder to follow while debugging due to not being able to step through. So I figured out what it did, and wrote out its output C++ code in full:<br /><br /><a href="http://partimage.svn.sourceforge.net/viewvc/partimage/trunk/partimage/src/client/interface_none.cpp?revision=1&view=markup&pathrev=20#l_103">interface_none.cpp, line 103</a><br /><pre><code>#define MB_2(One,Other,ONE,OTHER)       \<br />int CInterfaceNone::msgBox##One##Other(char *title, char *text, ...) {  \<br />char *result= lookup(title,text,&quot;(unspecified)&quot;);     \<br />va_list al;          \<br />va_start(al,text);         \<br />message_only(#One &quot;/&quot; #Other, title, text, al, result);    \<br />va_end(al);          \<br />if (!strcasecmp(result,#One)) return MSGBOX_##ONE;     \<br />if (!strcasecmp(result,#Other)) return MSGBOX_##OTHER;    \<br />invalid_programmed_response();       \<br />return 0;                                                             \<br />}<br /><br />MB_2(Continue,Cancel,CONTINUE,CANCEL)<br />MB_2(Yes,No,YES,NO)</code></pre><br /><br />my expanded version:<br /><pre><code>//notes: have expanded out macro so I can step through it.<br />int CInterfaceNone::msgBoxContinueCancel(char *title, char *text, ...) {<br /> char *result= lookup(title,text,&quot;(unspecified)&quot;);<br /> va_list al;          <br /> va_start(al,text);         <br /> message_only(&quot;Continue&quot; &quot;/&quot; &quot;Cancel&quot;, title, text, al, result);    <br /> va_end(al);          <br /> if (!strcasecmp(result,&quot;Continue&quot;)) return MSGBOX_CONTINUE;    <br /> if (!strcasecmp(result,&quot;Cancel&quot;)) return MSGBOX_CANCEL;    <br /> invalid_programmed_response();       <br />return 0;                                                             <br />}<br /><br />int CInterfaceNone::msgBoxYesNo(char *title, char *text, ...) {  <br /> char *result= lookup(title,text,&quot;(unspecified)&quot;);     <br /> va_list al;          <br /> va_start(al,text);         <br /> message_only(&quot;Yes&quot; &quot;/&quot; &quot;No&quot;, title, text, al, result);    <br /> va_end(al);          <br /> if (!strcasecmp(result,&quot;Yes&quot;)) return MSGBOX_YES;     <br /> if (!strcasecmp(result,&quot;No&quot;)) return MSGBOX_NO;    <br /> invalid_programmed_response();       <br /> return 0;                                                             <br />}</code></pre><br /><br /><strong>creating a ramdisk for testing.</strong><br /><a href="http://www.vanemery.com/Linux/Ramdisk/ramdisk.html">http://www.vanemery.com/Linux/Ramdisk/ramdisk.html</a><br />(I am on ubuntu 6.10 here, details may vary)<br /><br /><pre><code>$ ls -l /dev/ram*<br />brw-rw---- 1 root disk 1,  0 2007-04-08 20:10 /dev/ram0<br />brw-rw---- 1 root disk 1,  1 2007-04-08 20:10 /dev/ram1<br />brw-rw---- 1 root disk 1, 10 2007-04-08 20:10 /dev/ram10<br />brw-rw---- 1 root disk 1, 11 2007-04-08 20:10 /dev/ram11<br />brw-rw---- 1 root disk 1, 12 2007-04-08 20:10 /dev/ram12<br />brw-rw---- 1 root disk 1, 13 2007-04-08 20:10 /dev/ram13<br />brw-rw---- 1 root disk 1, 14 2007-04-08 20:10 /dev/ram14<br />brw-rw---- 1 root disk 1, 15 2007-04-08 20:10 /dev/ram15<br />brw-rw---- 1 root disk 1,  2 2007-04-08 20:10 /dev/ram2<br />brw-rw---- 1 root disk 1,  3 2007-04-08 20:10 /dev/ram3<br />brw-rw---- 1 root disk 1,  4 2007-04-08 20:10 /dev/ram4<br />brw-rw---- 1 root disk 1,  5 2007-04-08 20:10 /dev/ram5<br />brw-rw---- 1 root disk 1,  6 2007-04-08 20:10 /dev/ram6<br />brw-rw---- 1 root disk 1,  7 2007-04-08 20:10 /dev/ram7<br />brw-rw---- 1 root disk 1,  8 2007-04-08 20:10 /dev/ram8<br />brw-rw---- 1 root disk 1,  9 2007-04-08 20:10 /dev/ram9</code></pre><br /><br />create and mount test ramdisk<br /><pre><code># mke2fs /dev/ram0<br /># mkdir /media/ram0<br /># mount /dev/ram0 /media/ram0</code></pre><br />add a test file and unmount the disk<br /><pre><code># echo &quot;test data #1.&quot; &gt;&gt; /media/ram0/foo.txt<br /># umount /media/ram0</code></pre><br /><br />the above, as a script:<br /><pre><code>#!/bin/bash<br /># create and mount test ramdisk<br />mke2fs /dev/ram0<br />if [ ! -d /media/ram0 ]; then<br />    mkdir /media/ram0<br />fi<br />mount /dev/ram0 /media/ram0<br />#add a test file and unmount the disk<br />echo &quot;test file.&quot; &gt;&gt; /media/ram0/foo.txt<br />date &gt;&gt; /media/ram0/foo.txt<br />cat /media/ram0/foo.txt<br />umount /media/ram0</code></pre><br /><br />Create &amp; run script (as root, because it (un)mounts a file system, and creates a dir in a root owned folder):<br /><pre><code>$ gedit mkram.sh<br />$ chmod ug+x mkram.sh<br />$ sudo ./mkram.sh</code></pre><br /><br />Wierdly, partimage won't run in full batch mode without a second part to the -B switch, even if it's set up to not need to ask any questions. Supplying a  dummy &quot;x=y&quot; seems sufficient to fool it.<br /><br />Runing as root without asking for partition description works:<br /><pre><code>$ sudo ./partimage -d -B x=y save /dev/ram0 ram0.img</code></pre><br /><br />Restore image to a different ramdisk and check file:<br /><pre><code>$ sudo ./partimage -B x=y restore /dev/ram1 ram0.img.000<br />$ sudo mount /dev/ram1 /media/ram1<br />$ cat /media/ram1/foo.txt<br />test file.<br />Mon Apr  9 12:56:59 BST 2007</code></pre><br />Success!<br /><br />Script for checking file in saved partition:<br /><pre><code>#!/bin/bash<br /># mount and check restored ramdisk<br />if [ ! -d /media/ram1 ]; then<br />    mkdir /media/ram1<br />fi<br />mount /dev/ram1 /media/ram1<br />cat /media/ram1/foo.txt<br />umount /media/ram1</code></pre><br /><br />To debug in KDevelop as root (in ubuntu):<br />alt-F2 (run)<br />gksudo kdevelop<br />open project... (go find existing copy)<br /><br />So in summary, I have made progress in understanding the ways of this useful utility, and am a step closer to making a useful contribution to the project.<br /><br />The rambling nature of this post reflects the way in which one begins to understand a new program. Hopefully it's not too hard to follow, or pick out the useful pieces. All feedback gratefully appreciated.<br /><br />Tim.